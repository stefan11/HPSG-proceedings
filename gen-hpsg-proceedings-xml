#!/usr/local/bin/perl
#
# CC-BY Stefan Müller (HU Berlin)
#

# This script takes PDFs of single papers in Include/ and generates a wrapper with a title page that
# includes the pdf.
# It also creates a LaTeX file including all single papers with titles to create a single volume
# with all papers.
# Both the single volume and the individual papers are included into a large XML file.
# Stefan Müller 22.09.2021

use File::Copy;

use Encode;

use utf8;

use Term::ANSIColor;

use MIME::Base64 qw(encode_base64);

binmode(STDOUT, "encoding(UTF-8)");
#use open ":std", ":encoding(UTF-8)";

require './config.pl';

$location = Encode::decode("utf8", $location);
$maintainer = Encode::decode("utf8", $maintainer);
$editors_string = Encode::decode("utf8", $editor);
$conf_date = Encode::decode("utf8", $conf_date);

$today = `date +'%Y-%m-%d'`; chop($today);

$published = $today unless ($published);

# global counters for the whole XML document

$publication_id = 0;
$author_id      = 0;


# probably you do not want to change anything below
###################################################################################################

$conf_file  = lc($conf_name) . $year;


$proc_titlepage = $proc_title;
$proc_titlepage =~ s/on Head-Driven/on\\par Head-Driven/;
$location_tex = transform_to_latex($location);
$location_tex =~ s/\//\\slash /g;
$location_tex_without_br = $location_tex;
$location_tex_without_br =~ s/\\\\/ /g;

if ($location_short) {
    $proc_title_location = "$proc_title, " . $location_short;
} else {
    $proc_title_location = "$proc_title, " . $location_tex_without_br;
}
$proc_title_location_tex = "{" . transform_to_latex($proc_title_location) . "}";

unless (-e "Includes/ccby-eps-converted-to.pdf") {
print STDERR "Please provide ccby-eps-converted-to.pdf in the directory Includes/";
exit(0);
}


open(BIB, ">${conf_file}.bib");

$editor_tex = $editors_string;

$editor_tex =~ s/&/and/g;

$editor_tex = transform_to_latex($editor_tex); 

print BIB <<EOF;
\@proceedings{$crossref,
  editor    = {$editor_tex},
  title     = {$proc_title_location_tex},
  booktitle = {$proc_title_location_tex},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/},
  publisher = {CSLI Publications},
  address   = {Stanford, CA},
  OPTissn   = {$issn},
  year      = {$year},
}

EOF


open (PROCTMP, ">:utf8", "${conf_file}.tmp");

if ($editors_string =~ /&/) {
    $editors = "Editors";
} else {
    $editors = "Editor";
}


$editors_fn_ln       = author_first_name_last_name($editors_string);
$editors_fn_ln_latex = transform_author_first_name_last_name($editors_string);

        $title_pdfa = transform_to_plain_ascii($title);

        $editors_fn_ln_pdfa = $editors_fn_ln;
        $editors_fn_ln_pdfa =~ s/,/\\sep /g;


# \\begin{filecontents*}[overwrite]{\\jobname.xmpdata}
#         \\Title{$proc_title}
#         \\Author{$editors_fn_ln_pdfa ($editors)}
#         \\Language{en-US}
#%         \\Author{$editors_fn_ln_pdfa}
# %        \\Subject{$abstract}
#         \\Keywords{HPSG\\sep syntax\\sep grammar}
#         \\Copyright{CC-BY: the authors}
# %        \\Journaltitle: (prism:issueName) The title of the journal in which the document was published.
#         \\Journalnumber{$issn}
# %\Volume: Journal volume.
# %\Issue: Journal issue/number.
# %\Firstpage:First page number of the published version of the document.
# %\Lastpage:
# %        \\Doi{$doi}
#     \\end{filecontents*}

# %\\usepackage[bookmarks=true,bookmarksopen=true,%
# %breaklinks=true,%
# %draft=false,plainpages=false,hyperfootnotes=false,%
# %pdfauthor={$editors_fn_ln ($editors)},%
# %pdftitle={$proc_title},%
# %pdfkeywords={HPSG}%,
# %pdftex=true%
# %ps2pdf=true  %ohne diesen Treiber geht der Zeilenumbruch in URLs
# %]{hyperref}% for pdf files


print PROCTMP <<EOF;
\\pdfminorversion=6 % this is needed to be able to include pdf 1.6. 
                    % For some reasons some old HPSG proceedings have pdf 1.6
\\begin{filecontents*}[overwrite]{\\jobname.xmpdata}
         \\Title{$proc_title}
         \\Language{en-US}
         \\Author{$editors_fn_ln_pdfa}
         \\Keywords{HPSG\\sep syntax\\sep grammar\\sep linguistics}
         \\Copyright{CC-BY: the authors}
         \\Journalnumber{$issn}
     \\end{filecontents*}
\\documentclass[11pt,a4paper,fleqn]{article}
\\usepackage{times}
\\thispagestyle{empty}


\\usepackage[T1]{fontenc}   % Silbentrennung

\\usepackage[utf8x]{inputenc}
                                                                                                                             
\\hyphenation{Acad-e-my}
\\usepackage{colorprofiles}
\\usepackage[a-2b,mathxmp]{pdfx}[2018/12/22]
\\hypersetup{bookmarksopen=true,
pdfauthor={$editors_fn_ln ($editors)},%
pdftitle={$proc_title},%
pdfkeywords={HPSG, syntax, grammar, linguistics}%,
}
%    \hypersetup{pdfstartview=}


\\hypersetup{colorlinks=false, pdfborder={0 0 0}}

\\usepackage{pdfpages}
\\pdfinclusioncopyfonts=1

\\usepackage{orcidlink}
EOF

if ($draft eq "yes") {
print PROCTMP <<EOF;
\\usepackage[text={Draft! Do not cite!}, color=red, scale=.65]{draftwatermark}
EOF
}

print PROCTMP <<EOF;
\\newcommand\\formatauthor[2]{\\begin{tabular}[t]{\@{}c\@{}}
  {\\LARGE#1\\strut}\\\\
  {\\small#2\\strut}\\\\
  \\rule{\\dimexpr0.5\\linewidth-1em}{0pt}
  \\end{tabular}\\xhfill\\ignorespaces}
\\newcommand\\xhfill{\\hspace{1em plus 1fill}}

\\begin{document}

\\begin{center}
{\\Large
                {\\bfseries $proc_titlepage\\par}

                \\vspace{8ex}

                     $location_tex\\\\[\\baselineskip]

                        $editors_fn_ln_latex ($editors)\\\\[\\baselineskip]

                                $year\\\\[\\baselineskip]
EOF

if ($publisher) {
print PROCTMP <<EOF;


                          $publisher\\\\[\\baselineskip]
EOF
}

print PROCTMP <<EOF;
%              http://csli-publications.stanford.edu/$conf_name/$year \\\\[4\\baselineskip]

The papers are published under a \\href{http://creativecommons.org/licenses/by/4.0/}{CC-BY license}:\\\\[3pt]
\\href{http://creativecommons.org/licenses/by/4.0/}{http://creativecommons.org/licenses/by/4.0/}
}
\\end{center}
\\newpage
\\tableofcontents

\\newpage

\\section*{Editor's note}
\\addcontentsline{toc}{section}{Editor's note}
EOF
close(PROCTMP);

#copy("${conf_file}.tmp proc-prefix.tex", ">${conf_file}.tex") or die("Cannot copy tex files: $!\n");
system("cat ${conf_file}.tmp editors-note.tex >${conf_file}.tex");

open (PROC, ">>:utf8", "${conf_file}.tex");

# let's check whether there was a workshop
if (-e "workshop.txt") {
   $workshop = "yes";
   open(WS, "<:encoding(UTF-8)", 'workshop.txt' );
}

# We only have the Part-Pages if there was both a conference and a workshop
if ($workshop) { 

print PROC <<EOF;


\\newpage
\\part{Contributions to the Main Conference}
\\thispagestyle{empty}
EOF

} # end if workshop

print PROC "\\newpage\n";

# the abstract can span multiple lines, so records have to be separated by lines with no content.
$/ = "\n\n";


open(CONF, "<:encoding(UTF-8)", 'conference.txt' )    or die("Cannot open 'conference.txt': $!\n");

          $page_offset++ if ($workshop);

$page_end = $page_offset;


# initialize the authors list. Needed to be able to deal with frequent names (Lee, Wang, ...)
%authors = {};

# initialize the filenames list. Needed to be able to deal with multiple submissions by the same
# author(s): dekuthy-meurers, dekuthy-meurers-2
%filenames = {};

while (<CONF>) {

# comment
   if (/^\/\//) {
      next;
  };

# empty lines
   next unless /#/;



# Author1 & Author 2 # Affiliation1 & Affiliation2  # Title                                        # Date                # page start # page end 

@record=split(/#/);

   #$publication_id +=1;

   process_record(@record);

}

if ($workshop) {

print PROC <<EOF;
\\part{Contributions to the Workshop}
\\thispagestyle{empty}
\\newpage
EOF

$page_end++;




while (<WS>) {

# comment
   if (/^\/\//) {
      next;
  };

# empty lines
   next unless /#/;



# Author1 & Author 2 # Affiliation1 & Affiliation2  # Title                                        # Date                # page start # page end 

@record=split(/#/);

   #$publication_id +=1;

   process_record(@record);

}

} # end if workshop

#$date = localtime(time);
$date = `date +'%d.%m.%Y (%T)'`; chop($date);


print PROC <<EOF;
\\end{document}
EOF

close(PROC);
close($bib_fh);

print STDERR "latexing the whole volume, first pass.\n";
        `pdflatex $conf_file`;
print STDERR "latexing the whole volume, second pass.\n";
        `pdflatex $conf_file`;

$filesize = -s "$conf_file.pdf";



##########################################################################################
# print XML header and opening

open (XML, ">:utf8", "$conf_file.xml");

# remove newlines in location for XML
$location =~ s/<br>/ /g;

print XML <<EOF;
<?xml version='1.0' encoding='UTF-8'?>
<issue xmlns="http://pkp.sfu.ca" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" published="1" current="1" access_status="1" url_path="" xsi:schemaLocation="http://pkp.sfu.ca native.xsd">
    <description locale="en_US">&lt;p class="author"&gt;$location&lt;br&gt;$conf_date&lt;/p&gt;&#xD;
        &lt;p class="author"&gt;Editors: $editors_fn_ln&lt;/p&gt;</description>
    <issue_identification>
        <year>$year</year>
        <title locale="en_US">$proc_title</title>
    </issue_identification>
    <date_published>$published</date_published>
    <last_modified>$today</last_modified>
  <issue_galleys>
    <issue_galley locale="en_US">
      <label>PDF</label>
      <issue_file>
        <file_name>$conf_file.pdf</file_name>
        <file_type>application/pdf</file_type>
        <file_size>$filesize</file_size>
        <content_type>1</content_type>
        <original_file_name>$conf_file.pdf</original_file_name>
        <date_uploaded>$today</date_uploaded>
        <date_modified>$today</date_modified>
        <embed encoding="base64">
EOF


open (FILE, "$conf_file.pdf") or die "$!";
while (read(FILE, $buf, 60*57)) {
    print XML encode_base64($buf);
}
  print XML <<EOF;
        </embed>
      </issue_file>
    </issue_galley>
  </issue_galleys>
<articles>
EOF

# now loop throgh the separate papers

# first reinitialize the counters and lists and set back the file handle

$page_end = $page_offset;

$publication_id = 0;
$author_id      = 0;


# initialize the authors list. Needed to be able to deal with frequent names (Lee, Wang, ...)
%authors = {};

# initialize the filenames list. Needed to be able to deal with multiple submissions by the same
# author(s): dekuthy-meurers, dekuthy-meurers-2
%filenames = {};

# go back to the beginning
seek CONF, 0, 0;

$section_ref = "CONFERENCE";

while (<CONF>) {

# comment
   if (/^\/\//) {
      next;
  };

# empty lines
   next unless /#/;



# Author1 & Author 2 # ORCID1 & ORCID2 # Affiliation1 & Affiliation2  # Title                                        # Date                # page start # page end 

@record=split(/#/);

   #$publication_id +=1;

   process_record_xml(@record);

}

if ($workshop) {

$page_end++;


seek WS, 0, 0;

$section_ref = "WORKSHOP";

while (<WS>) {

# comment
   if (/^\/\//) {
      next;
  };

# empty lines
   next unless /#/;



# Author1 & Author 2 # Affiliation1 & Affiliation2  # Title                                        # Date                # page start # page end 

@record=split(/#/);

   #$publication_id +=1;

   process_record_xml(@record);

}

} # end if workshop





#############################################################
# print closing of XML

print XML <<EOF;
</articles>
</issue>
EOF

close(XML);

exit (0);


sub make_filename{

local( $authors_string ) = @_;

        my @authors=split(/&/,$authors_string);

        s{\s+}{}g foreach @authors;     # remove white space (not just trainling, all white space)

if ($#authors < 1) { # single author

# find the last name
$authors[0] =~ /^(.*),(.*)$/;

# change to lower case
$filename = lc($1);

# check if there is already an author with this name (Lee, Kim, Wang, ...)
if ($authors{$filename}) {
    $first_name = lc($2);
    $filename = "$filename-$first_name";
                       }

  $authors{$filename} = 1; # set a flag that indicates that we used this name already.

$filename = eliminate_special_chars($filename);

} elsif ($#authors < 2) { # two authors: max-moritz.pdf

$authors[0] =~ /^(.*),/;

$lastname1 = lc($1);

$authors[1] =~ /^(.*),/;

$lastname2 = lc($1);


$filename = eliminate_special_chars("$lastname1-$lastname2");

} else { # more than two authors: mmx.pdf

    $initials = "";

foreach my $author (@authors) {

$author =~ /^(.*),/;

$initials = $initials . lc(substr($1,0,1));  # get the first character and turn it into lowercase.

}

    $filename = eliminate_special_chars($initials);

} # else

$filenames{$filename} ++;

if ($filenames{$filename} > 1) {
    $filename = $filename . "-${filenames{$filename}}";
}

return $filename;

}


sub make_bibtex {
	local( ($authors_string,$orcids,$affiliation,$title,$date,$status,$abstract,$keywords) ) = @_;


        $bib_file  = $file_name . ".pdf";

        open (AUBIB, ">${file_name}.bib");

        $authors_string =~ s/&/ and /g;



        $authors_tex = transform_to_latex($authors_string);

        $title = transform_to_latex($title);
        $title =~ s/\\\\//g;

        print AUBIB <<EOF;
\@inproceedings{${file_name}:${year},
  author    = {$authors_tex},
  title     = {$title},
  booktitle = {$proc_title_location_tex},
  editor    = {$editor_tex},
  OPTissn   = {$issn},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/${pdf_file}},
  publisher = {CSLI Publications},
  address   = {Stanford, CA},
  pages     = {$page_start--$page_end},
  year      = {$year},
}

\@inproceedings{${file_name}:${year}-cr,
  crossref  = {$crossref},
  author    = {$authors_tex},
  title     = {$title},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/${pdf_file}},
  pages     = {$page_start--$page_end},
}

\@proceedings{$crossref,
  editor    = {$editor_tex},
  title     = {$proc_title_location_tex},
  booktitle = {$proc_title_location_tex},
  publisher = {CSLI Publications},
  address   = {Stanford, CA},
  OPTissn   = {$issn},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/},
  year      = {$year},
}

EOF
        print BIB <<EOF;
\@inproceedings{${file_name}:${year},
  author    = {$authors_tex},
  title     = {$title},
  booktitle = {$proc_title_location_tex},
  editor    = {$editor_tex},
  OPTissn   = {$issn},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/${pdf_file}},
  publisher = {CSLI Publications},
  address   = {Stanford, CA},
  pages     = {$page_start--$page_end},
  year      = {$year},
}

\@inproceedings{${file_name}:${year}-cr,
  crossref  = {$crossref},
  author    = {$authors_tex},
  title     = {$title},
  url       = {http://cslipublications.stanford.edu/HPSG/${year}/${pdf_file}},
  pages     = {$page_start--$page_end},
}

EOF

}


sub make_proceedings_part {
	local( ($authors_string,$orcids,$affiliation,$title,$date,$status,$abstract,$keywords) ) = @_;

        $authors_fn_ln = transform_author_first_name_last_name($authors_string);

#        $authors_string =~ s/&/and/;

        $title_w_br = $title;

#       keep the breaks
        $title_w_br =~ s/<br>/\\par/g; 

        $title_w_br = transform_to_latex($title_w_br);

        $title_tex = transform_to_latex($title);
        $title_tex =~ s/\\\\//g; #remove newlines 

        $title_pdfa = transform_to_plain_ascii($title);

        $keywords_pdfa = $keywords;
        $keywords_pdfa =~ s/,/\\sep /g;
        
        $authors_fn_ln_pdfa = author_first_name_last_name($authors_string);
        $authors_fn_ln_pdfa =~ s/,/\\sep /g;


        $abstract =~ s/%/\\%/g;

        print PROC <<EOF;
        \\setcounter{page}{$page_start}
        \\phantomsection
        \\addcontentsline{toc}{section}{$authors_fn_ln: $title_tex}
EOF

        print_title_page(PROC);

        print PROC <<EOF;
\\includepdf[pages=-,pagecommand=\\thispagestyle{plain}]{Includes/${pdf_include_file}}
EOF


open (TEXFILE, ">:utf8", "${tex_file}") or die("Cannot open '${tex_file}': $!\n");

        print TEXFILE <<EOF;
\\pdfminorversion=6 % this is needed to be able to include pdf 1.6. 
                    % For some reasons some old HPSG proceedings have pdf 1.6
\\begin{filecontents*}[overwrite]{\\jobname.xmpdata}
        \\Title{$title_pdfa}
        \\Author{$authors_fn_ln_pdfa}
        \\Language{en-US}
        \\Subject{$abstract}
        \\Keywords{$keywords_pdfa}
        \\Copyright{CC-BY: $authors_fn_ln}
        \\Doi{$doi}
        %\Volume: Journal volume.
%\Issue: Journal issue/number.
\\Journaltitle{$proc_title}
\\Journalnumber{$issn}
\\Firstpage{$page_start}
\\Lastpage{$page_end}

    \\end{filecontents*}
\\documentclass[a4paper,11pt]{article}
\\usepackage{times}
\\usepackage{ogonek} % Dąbkowski
\\hyphenation{Acad-e-my}
\\usepackage{colorprofiles}
\\usepackage[a-2b,mathxmp]{pdfx}[2018/12/22]
%    \hypersetup{pdfstartview=}
\\usepackage{pdfpages}
\\pdfinclusioncopyfonts=1
\\usepackage[utf8]{inputenc}
%        \\usepackage{hyperref}
        \\hypersetup{pdfkeywords={$keywords_pdfa},
                         colorlinks=false, pdfborder={0 0 0}}
        \\setcounter{page}{$page_start}
\\usepackage{orcidlink}
EOF

if ($draft eq "yes") {
print TEXFILE <<EOF;
\\usepackage[text={Draft! Do not cite!}, color=red, scale=.65]{draftwatermark}
EOF
}

print TEXFILE <<EOF;
        \\begin{document}

\\newcommand\\formatauthor[2]{\\begin{tabular}[t]{\@{}c\@{}}
  {\\LARGE#1\\strut}\\\\
  {\\small#2\\strut}\\\\
  \\rule{\\dimexpr0.5\\linewidth-1em}{0pt}
  \\end{tabular}\\xhfill\\ignorespaces}
\\newcommand\\xhfill{\\hspace{1em plus 1fill}}
EOF

    print_title_page(TEXFILE);

print TEXFILE <<EOF;
\\includepdf[pages=-,pagecommand=\\thispagestyle{plain}]{Includes/${pdf_include_file}}
        \\end{document}
EOF

    close(TEXFILE);

#print stderr "$tex_file\n";
        `pdflatex $tex_file`;

}


sub print_title_page {
  local( $file ) = @_;

#  $ling_authors = $authors_string;
#  $ling_authors =~ s/&/,/g;          # Meurers, W. Detmar, De Kuthy, Kordula


  $ling_title = $title;
  $ling_title =~ s/<br>/ /g;          # Can there be a <br> in the title? I thought it is \\
  $ling_title =~ s/\\\\/ /g;
  $ling_title = transform_to_latex($ling_title);

#@authors=split(/&/,$authors_string);
# remove trainling white space
#s{^\s+|\s+$}{}g foreach @authors;

 $ling_authors = create_ling_name_list(@authors);

# Authors: Write out the last name and initials for all authors of a particular work. Use an ampersand (&) instead of the word "and" when listing multiple authors of a single work. e.g. Smith, J. D., & Jones, M.

# Titles: Capitalize only the first word of a title or subtitle, and any proper names that are part of
#    a title.

# Pagination: Use the abbreviation p. or pp. to designate page numbers of articles from periodicals
#  that do not use volume numbers, especially newspapers. These abbreviations are also used to
#      designate pages in encyclopedia articles and chapters from edited books.

#Indentation*: The first line of the entry is flush with the left margin, and all subsequent lines are indented (5 to 7 spaces) to form a "hanging indent".

# Underlining vs. Italics*: It is appropriate to use italics instead of underlining for titles of books and journals.

# http://blog.apastyle.org/apastyle/2011/07/punctuating-the-reference-list-entry.html

# check whether the last item ends in a dot, otherwise add one
  if ($ling_authors !~ /\.$/) {
     $ling_authors = $ling_authors . ".";
  }

# to do 

  @editors=split(/&/,$editors_string);

  s{^\s+|\s+$}{}g foreach @editors;

  $ling_editors= create_ling_editors_name_list(@editors);
  if (@editors > 1) {
    $Eds = "eds";
  } else {
    $Eds = "ed";
  }


# check title for exclamation or question mark
  if ($ling_title !~ /[!\.\?][}]*$/) {
    $ling_title = $ling_title . ".";
  }

# we print a APA style reference at the bottom of the title page.
# Yu, S. Y., Li, W. G., Huang, Q. S., Zhi-Huang, C., & Hou, C. (1991). A preliminary report on the
#  intervention trials of primary liver cancer in high-risk populations with nutritional
#  supplementation of selenium in China. \emph{Biological trace element research}, 29(3), 289-294. 

# http://www.library.cornell.edu/resrch/citmanage/apa
# Hammond, K. R., & Adelman, L. (1986). Science, values, and human judgment. In H. R. Arkes &
#  K. R. Hammond (Eds.), Judgement and decision making: An interdisciplinary reader (pp. 127-143). Cambridge, England: Cambridge University Press.
#

      $authors_with_affiliations = typeset_authors_affiliations();

  print $file <<EOF;
\\thispagestyle{empty}

\\begin{center}
  {\\huge\\bfseries $title_w_br\\par}

  \\bigskip

~\\\\
\\begingroup
\\setlength{\\leftskip}{0pt plus 1fill}
\\setlength{\\rightskip}{0pt plus 1fill}
\\setlength{\\parindent}{0pt}
\\setlength{\\parfillskip}{0pt}
  $authors_with_affiliations
\\par\\endgroup

  \\vspace*{8ex}

  $proc_titlepage

  \\bigskip

  $location_tex

  \\medskip

  $editors_fn_ln ($editors)

  \\medskip

  $year

  \\medskip

EOF

if ($publisher) {
print $file <<EOF;


                          $publisher\\\\[\\baselineskip]
EOF
}

print $file <<EOF;


  \\medskip

  pages $page_start--$page_end

  \\medskip

%  \\url{http://csli-publications.stanford.edu/$conf_name/$year}
\\end{center}
\\vfill

\\noindent
EOF
if ($keywords) {
  print $file "Keywords: $keywords\n";
}
else {
  print $file "\n";
}

  $doi = "10.21248/hpsg.$year.$publication_id";
  print $file <<EOF;


\\vfill
\\noindent
$ling_authors $year. $ling_title In $ling_editors ($Eds.), \\emph{$proc_title_location_tex},
$page_start--$page_end.
EOF
if ($address) {
    print $file "$address: ";
}
if ($publisher) {
    print $file "$publisher. ";
}

print $file "DOI: \\href{http://doi.org/$doi}{$doi}. \\hfill\\href{http://creativecommons.org/licenses/by/4.0/}{\\includegraphics[height=.75em]{Includes/ccby-eps-converted-to.pdf}}\n
\\newpage";

}


sub process_record {
	local( @record ) = @_;



# remove trailing white space
s{^\s+|\s+$}{}g foreach @record; 

   if ($record[5] eq "no") { # not submitted

#print STDERR "not submitted!!!!\n\n";

      return;
   } elsif ($record[5] eq "pending") {
       print_warning("$record[0] is missing\n");
       return;
   }

   if ($record[4] !~ /\-/) { #does not contain a dash and hence is something like 22 October, 2015 
       print_warning("date in wrong format: $record[4]!\n");
       exit;
   } 

# we need this in the first pass already to get the DOI right.
   $publication_id +=1;


# remove whitespace before and after separator in authors, orcids, and affiliations
@record[0]=~ s/\s*&\s*/&/g;
@record[1]=~ s/\s*&\s*/&/g;
@record[2]=~ s/\s*&\s*/&/g;

    

    @authors=split(/&/,$record[0]);

    # remove trailing white space
    # not needed any longer, since done in the beginning
    # s{^\s+|\s+$}{}g foreach @authors;

    $no_of_authors = @authors;

    @orcids=split(/&/,$record[1]);


    @affiliations=split(/&/,$record[2]);

    $no_of_affiliations = @affiliations;


   $file_name = make_filename($record[0]); # record[0] = the authors

   $pdf_include_file  = $file_name . ".pdf";

   # The paper prefix is something like hpsg2018. Earlier proceedings do not have this.
   # Introducing it now would change the URLs.
   if ($paper_prefix) {
   $pdf_file  = $paper_prefix . "-" . $file_name . ".pdf";

   $tex_file  = $paper_prefix . "-" . $file_name . ".tex";

   } else {
          $pdf_file  = $file_name . ".pdf";

          $tex_file  = $file_name . ".tex";
   }

   if ($record[6] =~ /^\s*pdf/) {
        $abstr_file = "abstr-${file_name}.pdf";
      }
   else {
       $abstr_file = "abstr-${file_name}.shtml";
   }

       print STDERR "processing: $file_name, $record[0],$record[2] \n";


        $numberofpages = `pdftk Includes/$pdf_include_file dump_data | grep NumberOfPages`;

        chop($numberofpages);

        $numberofpages =~ s/NumberOfPages: //;

        $numberofpages++;  # we have to add 1 since the title page is not in the PDF

        $page_start = $page_end   + 1;
        $page_end   = $page_start + $numberofpages - 1;


        #print "$pdf_file: ($numberofpages) $page_start-$page_end\n";

           make_bibtex(@record);
           
          print_warning("Keywords empty!\n") unless ($record[7]);

          make_proceedings_part(@record);
           


}


sub process_record_xml {
	local( @record ) = @_;



# remove trailing white space
s{^\s+|\s+$}{}g foreach @record; 

   if ($record[5] eq "no" || $record[5] eq "pending" ) { # not submitted (yet)

#print STDERR "not submitted!!!!\n\n";

      return;
   } 

   $publication_id +=1;

  $doi = "10.21248/hpsg.$year.$publication_id";

# remove whitespace before and after separator in authors, orcids, and affiliations
@record[0]=~ s/\s*&\s*/&/g;
@record[1]=~ s/\s*&\s*/&/g;
@record[2]=~ s/\s*&\s*/&/g;

# remove newlines
@record[0]=~ s/\n//g; # author
@record[2]=~ s/\n//g; # affiliation
@record[3]=~ s/\n//g; # title



    @authors=split(/&/,$record[0]);

    # remove trailing white space
    # not needed any longer, since done in the beginning
    # s{^\s+|\s+$}{}g foreach @authors;

    $no_of_authors = @authors;

    @orcids=split(/&/,$record[1]);


    @affiliations=split(/&/,$record[2]);

    $no_of_affiliations = @affiliations;


   $file_name = make_filename($record[0]); # record[0] = the authors

   $pdf_include_file  = $file_name . ".pdf";

   # The paper prefix is something like hpsg2018. Earlier proceedings do not have this.
   # Introducing it now would change the URLs.
   if ($paper_prefix) {
   $pdf_file  = $paper_prefix . "-" . $file_name . ".pdf";

   $tex_file  = $paper_prefix . "-" . $file_name . ".tex";

   } else {
          $pdf_file  = $file_name . ".pdf";

          $tex_file  = $file_name . ".tex";
   }

   if ($record[6] =~ /^\s*pdf/) {
        $abstr_file = "abstr-${file_name}.pdf";
      }
   else {
       $abstr_file = "abstr-${file_name}.shtml";
   }

       print STDERR "processing: $file_name, $record[0],$record[2] \n";

#   if ($record[5] ne "pending") {

 #      if ($record[5] ne "no" && $record[5] ne "pending") {

        $numberofpages = `pdftk Includes/$pdf_include_file dump_data | grep NumberOfPages`;

        chop($numberofpages);

        $numberofpages =~ s/NumberOfPages: //;

        $numberofpages++;  # we have to add 1 since the title page is not in the PDF

        $page_start = $page_end   + 1;
        $page_end   = $page_start + $numberofpages - 1;


        #print "$pdf_file: ($numberofpages) $page_start-$page_end\n";

#           make_bibtex(@record);
           
#          print_warning("Keywords empty!") unless ($record[6]);

#          make_proceedings_part(@record);
           
#       };
#   };
     
    @authors=split(/&/,$record[0]);
    #print STDERR "@authors\n\n\n";

    #$abstract=$record[6];

    #print STDERR "$abstract\n\n\n";

#print STDERR "$record[1],$record[3],$record[4],$record[6],$record[7]\n";
#print STDERR "$record[1]\n";

 #print_record_xml($record[0],$pdf_file,$page_start,$page_end,$title,$date,$abstract,$keywords);
 print_record_xml($record[0],$record[1],$record[2],$pdf_file,$page_start,$page_end,$record[3],$record[4],$record[6],$record[7]);

}



sub author_first_name_last_name{
	local($names_string) = @_;

        @names=split(/&/,$names_string);

        @names_fn_ln = ();

        foreach my $name (@names) {
 	  $name =~ /\s*(.*),\s*(.*)\s*/;
          $firstname = $2;
          $lastname = $1;
#          $firstname =~ s/^\s+|\s+$//g;  # remove trainling space
#          $lastname =~ s/^\s+|\s+$//g;
#          print "firstname: '${firstname}' lastname: '${lastname}'\n"; 
          push(@names_fn_ln, "$firstname $lastname" );
        } 

        return join(", ", @names_fn_ln);

}


sub transform_author_first_name_last_name{
	local($names_string) = @_;

        return transform_to_latex(author_first_name_last_name($names_string));

}

# Ginzburg, Jonathan, & Lücking, Andy. 
sub create_apa_name_list{
	local(@authors) = @_;

  # number of names = @authors
  my $no_of_names = @authors;

  $i = 0;
  $apa_name_list = "";
        while ($authors[$i]) {
            $apa_name_list = $apa_name_list . $authors[$i];

            if ($i + 1 < $no_of_names) {
                $apa_name_list = $apa_name_list . ", ";
            }
            if ($i + 2 == $no_of_names) {
                $apa_name_list = $apa_name_list . "\\& ";
            }
            $i++;
        }
          return $apa_name_list;
}

# Arad Greshler, Tali,  Livnat Herzig Sheinfux, Nurit Melnik & Shuly Wintner.
sub create_ling_name_list{
	local(@authors) = @_;

  # number of names = @authors
  my $no_of_names = @authors;

  $i = 1;
  $ling_name_list = $authors[0];   # the first author remains Lastname, Firstname
        while ($authors[$i]) {

            if ($i + 1 < $no_of_names) {
                $ling_name_list = $ling_name_list . ", ";
            }
            if ($i + 1 == $no_of_names) {
                $ling_name_list = $ling_name_list . " \\& ";
            }

            @authors[$i] =~ /\s*(.*),\s*(.*)\s*/;
            $firstname = $2;
            $lastname = $1;

            $ling_name_list = $ling_name_list . "$firstname $lastname";

            $i++;
        }
          return $ling_name_list;
}

# for the editors we have to reverse the first editor's name as well

sub create_ling_editors_name_list{
	local(@authors) = @_;

  # number of names = @authors
  my $no_of_names = @authors;

  $i = 0;
  $ling_name_list = "";
        while ($authors[$i]) {

            @authors[$i] =~ /\s*(.*),\s*(.*)\s*/;
            $firstname = $2;
            $lastname = $1;

            $ling_name_list = $ling_name_list . "$firstname $lastname";

            if ($i + 2 < $no_of_names) {
                $ling_name_list = $ling_name_list . ", ";
            }
            if ($i + 2 == $no_of_names) {
                $ling_name_list = $ling_name_list . " \\& ";
            }

            $i++;
        }
          return $ling_name_list;
}


sub typeset_authors_affiliations{


    $a_af = "";

    $i = 0;

    # parallel to the top entry.        
    while ($i < $no_of_authors) {


        @authors[$i] =~ /\s*(.*),\s*(.*)\s*/;
        $firstname = $2;
        $lastname = $1;

        $a_af = $a_af . "\\formatauthor{$firstname" . " " . $lastname;
        if (@orcids[$i] =~ /-/) { # 0000-0000-0000-0000 rather than "no", "mailed" or "unknown"
          $a_af = $a_af . "\\,\\orcidlink{@orcids[$i]}";
        }
        $a_af = $a_af . "}";
        

        if ($no_of_affiliations == 1) { 
           $affiliations_w_break = @affiliations[0];
        } elsif ($i <= $no_of_affiliations) {
           $affiliations_w_break = @affiliations[$i];
        }
        if ($affiliations_w_break eq "no") {
          $affiliations_w_break =""; # nothing provided
        } else {
          $affiliations_w_break =~ s/§/\\\\/g;
        }
        $a_af = $a_af . "{\\begin{tabular}{\@{}c\@{}}" . $affiliations_w_break . "\\end{tabular}}\n";

        $i++;
    }
 
    return $a_af;

}


sub transform_to_latex {
	local($string) = @_;

%utf8_character_map =
    (
     'Æ', '\AE',
#     '\'{A}', '&#193;',
#     '\^{A}', '&#194;', 
#     '\`{A}', '&#192;' ,
#     '\AA'  , '&#197;' ,
#     '\~{A}', '&#195;' ,
#     '\"{A}', '&#196;' ,
#     '\c{C}', '&#199;' ,
#     '\'{E}', '&#201;' ,
#     '\^{E}', '&#202;' ,
#     '\`{E}', '&#200;' ,
#     '\"{E}', '&#203;' ,
#     "'"    , '&#180;' ,
#     '\'{I}', '&#205;' ,
#     '\^{I}', '&#206;' ,
#     '\`{I}', '&#204;' ,
#     '\"{I}', '&#207;' ,
#     '\~{N}', '&#209;' ,
      'Ø',   '{\O}', 
#     '\^{O}', '&#212;' ,
#     '`{O}', '&#210;' ,  # \`
#     '\O'   , '&#216;' ,
#     '\~{O}', '&#213;' ,
#     '\"{O}', '&#214;' ,
#     '\P'   , '&#182;' ,
#     '\S'   , '&#167;' ,
#     '\'{U}', '&#218;' ,
#     '\^{U}', '&#219;' ,
#     '\`{U}', '&#217;' ,
#     '\"{U}', '&#220;' ,
#     '\'{Y}', '&#221;' ,
#     '\'{a}', '&#225;' ,
#     '\^{a}', '&#226;' ,
     'æ', '\ae',
#     '`{a}', '&#224;' , # \'
#     '&'    , '&amp;' ,
#     '\^{a}', '&#229;' ,
#     '\~{a}', '&#227;' ,
      'ä',     '\"a', 
     'ă',     '\u{a}',
          'ą', '\k{a}',
#     '\c{c}', '&#231;' ,
#     '\c'   , '&#184;' ,
#     '\^{}' , '^' ,
#     '\copyright', '&#169;' ,
      'é',  '\\\'e', 
#     '\^{e}', '&#234;' ,
      'è',  '\`e', 
#     '\v{o}', '&#240;' ,
#     '\"{e}', '&#235;' ,
#     '!`'   , '&#161;' ,
#     '>'    , '&#62;' ,
#     '\'{i}', '&#237;' ,    # this was taken from latex2html but seems to be wrong
#     '\'\i',  '&#237;' ,    
#     '^{i}', '&#238;',    # I do not understand this backslash business in i_j_rx expression below, but this works
#     '\`{i}', '&#236;' ,
#     '\"{i}', '&#239;' ,
#     '<'    , '&lt;' ,
#     '\~{n}', '&#241;' ,
      'ó', '\\\'o', 
#     '\^{o}', '&#244;' ,
#      '\`{o}', 
      'ø', '{\o}',
#     '\~{o}', '&#245;' ,
     'ö', '\\"o',
#     '&#175;' , '\={}',
#     '&#163;' , '\pounds',
#     '&#191;' , '?`',
#     '&#183;' , '\^{}',
     'ß', '\ss',
#     '\"{s}', '&#223;' ,
#     '\~{}' , '&#126;' ,
#     '\'{u}', '&#250;' ,
     'û', '{\^u}',
#     '\`{u}', '&#249;' ,
     'ü',  '\\"u',
#     '\'{y}', '&#253;' ,
#     '\"{y}', '&#255;' ,

#     '\'{c}', '&#263;' ,
      'ć',  '\\\'c',
#     '\'{C}', 'C' ,
#     '\v{c}', '&#269;',

#     '\'{n}', '&#324;' ,   # some Polish stuff
#     '\'{N}', '&#323;' ,

#     '\'{s}', '&#347;' ,
#     '{\'s}', '&#347;' ,
      'ś', '\\\'s',
#     '\'{S}', 'S' ,
     'ż', '\.z',
     'ń', '\\\'n',
     '′', '$\'$'

);


# is this needed? We can do unicode now, can't we?
# The ` of X-bar does not work it needs utf8x/utf8 and hangs. 12.10.2021
	$string =~ s/((ä|ă|ą|ö|ü|ÄÖ|Ü|æ|Æ|Œ|œ|è|é|Ø|ø|û|ó|ś|ć|ń|ż|′))/$utf8_character_map{"$1"}/geo;    
#	$string =~ s/((ă|ą|æ|Æ|Œ|œ|è|é|Ø|ø|û|ó|ś|ć|ń|ż|′))/$utf8_character_map{"$1"}/geo;    

#       this cannot cope with nesting
#        $string =~ s/<em>(.*)<\/em>/\\emph{$1}/g;
        $string =~ s/<em>/\\emph{/g;
        $string =~ s/<\/em>/}/g;

        $string =~ s/<q>(.*)<\/q>/``$1''/g;

        $string =~ s/<br>/\\\\/g;  # remove explicit breaks

        $string =~ s/&ndash;/--/g;

        $string =~ s/&mdash;/---/g;

	return $string;
}



sub eliminate_special_chars{
	local($string) = @_;

%utf8_character_map =
    (
     'Æ', 'Ae',
     'æ', 'ae',
     'ă', 'a',
     'ą', 'a',
     'á', 'a',
     'é', 'e',
     'è', 'e',
     'ė', 'e',
     'ó', 'o', 
     'Ø', 'Oe',
     'ø', 'oe',
     'ö', 'oe',
     'ß', 'ss',
     'ś', 's',
     'š', 's',
     'ć', 'c',
     'û', 'u',
     'î', 'i',
     'í', 'i',
     'ï', 'i',
     'ü',  'ue',
     'ñ', 'n',


);

	$string =~ s/((ä|ă|á|ą|ö|ü|Ä|Ö|Ü|î|í|ï|ś|š|ć|æ|Æ|Œ|œ|è|é|ė|Ø|ø|û|ó|ñ))/$utf8_character_map{"$1"}/geo;    


	return $string;
}


sub transform_to_plain_ascii {
	local($string) = @_;


#       this cannot cope with nesting
#        $string =~ s/<em>(.*)<\/em>/\\emph{$1}/g;
        $string =~ s/<em>//g;
        $string =~ s/<\/em>//g;

        $string =~ s/<q>(.*)<\/q>/"$1"/g;

        $string =~ s/<br>//g;  # remove explicit breaks

        $string =~ s/&ndash;/–/g;

        $string =~ s/&mdash;/–/g;

	return $string;
}



sub print_warning{
	local($warning) = @_;


          print STDERR color('red');
          print STDERR "Warning:"; 
          print STDERR color('reset');
          print STDERR $warning;
} 


sub print_record_xml{
	local( ($authors,$orcids,$affiliations,$pdf_file,$page_start,$page_end,$title,$date,$abstract,$keywords) ) = @_;


$filesize = -s $pdf_file;

$abstract=~ s/\&/\&amp;/g;
$abstract=~ s/</\&lt;/g;
$abstract=~ s/>/\&gt;/g;
$abstract=~ s/<q>/"/g;
$abstract=~ s/<\/q>/"/g;
$abstract=~ s/`/&#715;/g;



# OJS does not allow for HTML in titles. This may be fixed sometime. For now I remove italics. St. Mü. 30.09.2021
$title=~ s/<em>//g;
$title=~ s/<\/em>//g;

$title=~ s/<q>/"/g;
$title=~ s/<\/q>/"/g;
$title=~ s/`/&#715;/g;

# line breaks are needed for LaTeX typesetting. Remove them in XML
$title=~ s/<br>//g;

# remove decapitalization protection for LaTeX, which was used in some years
$title=~ s/{//g;
$title=~ s/}//g;



  print XML <<EOF;
  <article status="3" submission_progress="0" stage="production" date_submitted="$date">
    <submission_file id="$publication_id" file_id="$publication_id" stage="proof" updated_at="$today" viewable="false" genre="Article Text" uploader="ojs_admin">
      <name locale="en_US">$pdf_file</name>
      <file id="$publication_id" filesize="$filesize" extension="pdf">
        <embed encoding="base64">
EOF


open (FILE, $pdf_file) or die "$!";
while (read(FILE, $buf, 60*57)) {
    print XML encode_base64($buf);
}
  print XML <<EOF;
</embed>
      </file>
    </submission_file>
    <publication locale="en_US" version="1" status="3" seq="$publication_id" date_published="$date" section_ref="$section_ref" access_status="0">
      <id type="doi" advice="update">$doi</id>
      <title locale="en_US">$title</title>
      <abstract locale="en_US">
&lt;p&gt;$abstract&lt;/p&gt;</abstract>
      <copyrightYear>2021</copyrightYear>
EOF

print_authors_xml($authors,$orcids,$affiliations);



  print XML <<EOF;
      <article_galley locale="en_US" approved="false">
        <name locale="en_US">PDF</name>
        <seq>0</seq>
        <submission_file_ref id="$publication_id"/>
      </article_galley>
      <issue_identification>
        <year>$year</year>
        <title locale="en_US">$proc_title</title>
      </issue_identification>
      <pages>$page_start–$page_end</pages>
    </publication>
  </article>
EOF

# was before year but is not needed since there is only one volume per year.  <volume>$volume</volume>



}


sub print_authors_xml{
	local( ($authors,$orcids,$affiliations) ) = @_;

    my $author_seq = 0;

    @authors=split(/&/,$authors);
    @orcids =split(/&/,$orcids);

#s{^\s+|\s+$}{}g foreach @orcids; # I do not understand why we still have space here.

    @affiliations=split(/&/,$affiliations); # The number of affiliations can be less or equal to the
                                # number of authors. Authors can have the same affiliation.

        $i = 0;

       print XML <<EOF;
<authors>
EOF

        while ($i < @authors) {

        @authors[$i] =~ /\s*(.*),\s*(.*)\s*/;
        $firstname = $2;
        $lastname = $1;

        $author_seq +=1;
        $author_id  +=1;

$no_affs=@affiliations;

#print STDERR "@affiliations[0], $no_affs\n";
        if (@affiliations == $i) { # The number of affiliations is smaller than our author number. 
                                # i = 0, 1, 2. aff=1 oder 2
           $affiliation = @affiliations[$no_affs-1];   # take the last affiliation that is availible
#print STDERR "aff: $affiliation\n";

        } else {
           $affiliation = @affiliations[$i];                # take the affiliation corresponding to
                                                            # the author number
        } 
#        <givenname locale="en_US">Berthold</givenname>
#        <familyname locale="en_US">Crysmann</familyname>
#    <affiliation locale="en_US">HU Berlin</affiliation>
#        <country>FK</country>
#    
#          <email>https://example.com</email>
#    <url>https://example.com</url>
#    <orcid>0000-0000-0000-0000</orcid>
#    <biography locale="en_US">Lorem Ipsum</biography>

#     @orcids[$i] = "0000-0000-0000-0000" unless @orcids[$i];

print XML <<EOF;
        <author include_in_browse="true" user_group_ref="Author" seq="$author_seq" id="$author_id">
        <givenname locale="en_US">$firstname</givenname>
        <familyname locale="en_US">$lastname</familyname>
        <affiliation locale="en_US">$affiliation</affiliation>
        <country>FK</country>
        <email>none\@ojs.example</email>
EOF
        if (@orcids[$i] =~ /-/) { # contains dash
            print XML "        <orcid>https://orcid.org/@orcids[$i]</orcid>\n";
        } elsif (@orcids[$i] ne "no") {# && @orcids[$i] ne "mailed" && @orcids[$i] ne "unknown") {
            print_warning("No ORCID for $firstname $lastname, $affiliation!\n\n");
        }
print XML <<EOF;
        </author>
EOF


        $i++;
       } 
        print XML "</authors>\n";

}
